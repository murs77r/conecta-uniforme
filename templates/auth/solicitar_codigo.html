{% extends "base.html" %}

{% block title %}Login - Conecta Uniforme{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-5">
        <div>
            <div class="card-body p-5">
                <div class="text-center mb-4">
                    <i class="bi bi-shop text-primary" style="font-size: 4rem;"></i>
                    <h2 class="mt-3">Conecta Uniforme</h2>
                    <p class="text-muted">Entre com seu email para receber o código de acesso</p>
                </div>
                
    <form method="POST" action="{{ url_for('autenticacao.solicitar_codigo') }}" id="formLogin" autocomplete="off">
                    <input type="hidden" name="tipo" id="tipo" value="">
                    <div class="mb-3">
                        <label for="email" class="form-label">Email</label>
                        <input type="email" class="form-control form-control-lg" id="email" name="email" value="{{ email or '' }}" required>
                    </div>
                    
          <div class="d-grid gap-2">
            <button type="submit" class="btn btn-primary btn-lg" id="btnEnviar">
              <i class="bi bi-envelope"></i> Enviar Código
            </button>
          </div>
                </form>
                
                <hr class="my-4">
                
                    <div class="text-center text-muted small">
                    <p class="mb-0">Você receberá um código de {{ CODIGO_ACESSO_TAMANHO }} dígitos no seu email.</p>
                    <p class="mb-0">O código é válido por {{ CODIGO_ACESSO_DURACAO_HORAS }} horas.</p>
                </div>
                {# Modal de seleção de tipo: obrigatório quando usuário possui múltiplos perfis (ex: escola+fornecedor) #}
                {# Não permite submit do form até que um tipo seja escolhido (backdrop: static, keyboard: false) #}
            </div>
        </div>
    </div>
</div>

{# Modal Bootstrap: exibe lista de perfis quando email tem múltiplos tipos de usuário #}
{# Preenchido dinamicamente via JavaScript ou renderizado pelo backend quando abrir_modal_tipo=True #}
<div class="modal fade" id="modalTipo" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Escolha o tipo de acesso</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
      </div>
      <div class="modal-body">
        <p>Este email possui mais de um perfil. Selecione como deseja entrar:</p>
        <div class="vstack gap-2">
          {% for t in tipos_disponiveis or [] %}
          <button class="btn btn-outline-primary w-100 escolha-tipo" data-tipo="{{ t }}">{{ t|title }}</button>
          {% endfor %}
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary cancelar-modal-tipo" data-bs-dismiss="modal">Cancelar</button>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// Expõe dicionário de rótulos de tipos para uso em JavaScript (mapeamento slug → label UI)
window.ROTULOS_TIPOS = JSON.parse('{{ ROTULOS_TIPOS | tojson | safe }}');

// Fluxo de autenticação com seleção obrigatória de tipo quando usuário tem múltiplos perfis
// Previne envio de formulário até que tipo seja explicitamente escolhido via modal
(function(){
  const form = document.getElementById('formLogin');
  const emailInput = document.getElementById('email');
  const tipoHidden = document.getElementById('tipo');
  const abrir = "{{ '1' if abrir_modal_tipo else '0' }}" === "1";  // Backend sinaliza necessidade de abrir modal
  let modalInstance = null;
  const modalEl = document.getElementById('modalTipo');

  function abrirModalTipos(){
    if(!modalEl) return;
    // backdrop: static = não fecha ao clicar fora; keyboard: false = não fecha com ESC
    if(!modalInstance){ modalInstance = new bootstrap.Modal(modalEl, {backdrop:'static', keyboard:false}); }
    modalInstance.show();
  }

  // Abre modal imediatamente se backend sinalizou múltiplos perfis (flag abrir_modal_tipo)
  if (abrir) {
    abrirModalTipos();
  }

  // Intercepta submit: valida se há múltiplos tipos ANTES de enviar ao backend
  // Evita round-trip desnecessário ao servidor quando já sabemos que precisa escolher tipo
  form.addEventListener('submit', async function(e){
    // Validação client-side: consulta endpoint /auth/tipos-por-email para verificar múltiplos perfis
    const emailVal = (emailInput.value||'').trim().toLowerCase();
    if(!emailVal){ return; }
    try{
      const resp = await fetch(`/auth/tipos-por-email?email=${encodeURIComponent(emailVal)}`);
      const j = await resp.json();
      // Se múltiplos tipos E nenhum tipo escolhido: bloqueia submit e força escolha
      if(Array.isArray(j.tipos) && j.tipos.length > 1 && !tipoHidden.value){
        e.preventDefault();
        // Preenche modal dinamicamente se veio vazio do HTML (lazy loading)
        const lista = modalEl.querySelector('.vstack');
        if(lista && (!lista.children || lista.children.length === 0)){
          lista.innerHTML = '';
          j.tipos.forEach(item => {
            const t = item.slug || item; // compat fallback
            const label = (item.label) || (window.ROTULOS_TIPOS && window.ROTULOS_TIPOS[t]) || (t.charAt(0).toUpperCase()+t.slice(1));
            const b = document.createElement('button');
            b.type = 'button';
            b.className = 'btn btn-outline-primary w-100 escolha-tipo';
            b.setAttribute('data-tipo', t);
            b.textContent = label;
            b.addEventListener('click', function(){
              tipoHidden.value = t;
              if(modalInstance){ modalInstance.hide(); }
              form.submit();
            });
            lista.appendChild(b);
          });
        }
        abrirModalTipos();
        return; // não submeter
      }
      // Caso único tipo: preenche automaticamente o campo hidden
      if(Array.isArray(j.tipos) && j.tipos.length === 1 && !tipoHidden.value){
        const unico = j.tipos[0];
        tipoHidden.value = (unico.slug || unico);
      }
      // Se nenhum tipo: deixa backend validar e retornar erro apropriado
    }catch(_){
      // Silencia erros de rede; backend fará validação definitiva
    }
    // Reforça: se backend sinalizou múltiplos perfis e usuário ainda não escolheu, bloqueia
    if (abrir && !tipoHidden.value){
      e.preventDefault();
      abrirModalTipos();
    }
  });

  // Click nos botões de escolha de tipo dentro do modal: preenche hidden e submete form
  document.querySelectorAll('.escolha-tipo').forEach(btn => {
    btn.addEventListener('click', function(){
      const tipo = this.getAttribute('data-tipo');
      tipoHidden.value = tipo;
      // Fecha modal e submete automaticamente
      if(modalInstance){ modalInstance.hide(); }
      form.submit();
    });
  });

  // Botão cancelar: limpa tipo escolhido e retorna foco ao email (recomeça fluxo)
  document.querySelectorAll('.cancelar-modal-tipo').forEach(btn => {
    btn.addEventListener('click', function(){
      tipoHidden.value='';
      // Delay para aguardar animação de fechamento do modal
      setTimeout(()=> emailInput.focus(), 250);
    });
  });

  // Observa mudanças no email: ao alterar, limpa tipo previamente selecionado (novo email = nova escolha)
  emailInput.addEventListener('input', ()=> { tipoHidden.value=''; });
})();
</script>
{% endblock %}
