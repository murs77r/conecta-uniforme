{% extends "base.html" %}

{% block title %}Login - Conecta Uniforme{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-5">
        <div>
            <div class="card-body p-5">
                <div class="text-center mb-4">
                    <i class="bi bi-shop text-primary" style="font-size: 4rem;"></i>
                    <h2 class="mt-3">Conecta Uniforme</h2>
                    <p class="text-muted">Entre com seu email para receber o código de acesso</p>
                </div>
                
    <form method="POST" action="{{ url_for('autenticacao.solicitar_codigo') }}" id="formLogin" autocomplete="off">
                    <input type="hidden" name="tipo" id="tipo" value="">
                    <div class="mb-3">
                        <label for="email" class="form-label">Email</label>
                        <input type="email" class="form-control form-control-lg" id="email" name="email" value="{{ email or '' }}" required>
                    </div>
                    
          <div class="d-grid gap-2">
            <button type="submit" class="btn btn-primary btn-lg" id="btnEnviar">
              <i class="bi bi-envelope"></i> Enviar Código
            </button>
            <button type="button" class="btn btn-outline-secondary btn-lg" id="btnPasskeyLogin" style="display:none;">
              <i class="bi bi-fingerprint"></i> Entrar com Passkey
            </button>
          </div>
                </form>
                
                <hr class="my-4">
                
                    <div class="text-center text-muted small">
                    <p class="mb-0">Você receberá um código de {{ CODIGO_ACESSO_TAMANHO }} dígitos no seu email.</p>
                    <p class="mb-0">O código é válido por {{ CODIGO_ACESSO_DURACAO_HORAS }} horas.</p>
                </div>
                {# Modal de seleção de tipo: obrigatório quando usuário possui múltiplos perfis (ex: escola+fornecedor) #}
                {# Não permite submit do form até que um tipo seja escolhido (backdrop: static, keyboard: false) #}
            </div>
        </div>
    </div>
</div>

{# Modal Bootstrap: exibe lista de perfis quando email tem múltiplos tipos de usuário #}
{# Preenchido dinamicamente via JavaScript ou renderizado pelo backend quando abrir_modal_tipo=True #}
<div class="modal fade" id="modalTipo" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Escolha o tipo de acesso</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
      </div>
      <div class="modal-body">
        <p>Este email possui mais de um perfil. Selecione como deseja entrar:</p>
        <div class="vstack gap-2">
          {% for t in tipos_disponiveis or [] %}
          <button class="btn btn-outline-primary w-100 escolha-tipo" data-tipo="{{ t }}">{{ t|title }}</button>
          {% endfor %}
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary cancelar-modal-tipo" data-bs-dismiss="modal">Cancelar</button>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// Expõe dicionário de rótulos de tipos para uso em JavaScript (mapeamento slug → label UI)
window.ROTULOS_TIPOS = JSON.parse('{{ ROTULOS_TIPOS | tojson | safe }}');

// Fluxo de autenticação com seleção obrigatória de tipo quando usuário tem múltiplos perfis
// Previne envio de formulário até que tipo seja explicitamente escolhido via modal
(function(){
  const form = document.getElementById('formLogin');
  const emailInput = document.getElementById('email');
  const tipoHidden = document.getElementById('tipo');
  const abrir = "{{ '1' if abrir_modal_tipo else '0' }}" === "1";  // Backend sinaliza necessidade de abrir modal
  let modalInstance = null;
  const modalEl = document.getElementById('modalTipo');

  function abrirModalTipos(){
    if(!modalEl) return;
    // backdrop: static = não fecha ao clicar fora; keyboard: false = não fecha com ESC
    if(!modalInstance){ modalInstance = new bootstrap.Modal(modalEl, {backdrop:'static', keyboard:false}); }
    modalInstance.show();
  }

  // Abre modal imediatamente se backend sinalizou múltiplos perfis (flag abrir_modal_tipo)
  if (abrir) {
    abrirModalTipos();
  }

  // Intercepta submit: valida se há múltiplos tipos ANTES de enviar ao backend
  // Evita round-trip desnecessário ao servidor quando já sabemos que precisa escolher tipo
  form.addEventListener('submit', async function(e){
    // Validação client-side: consulta endpoint /auth/tipos-por-email para verificar múltiplos perfis
    const emailVal = (emailInput.value||'').trim().toLowerCase();
    if(!emailVal){ return; }
    try{
      const resp = await fetch(`/auth/tipos-por-email?email=${encodeURIComponent(emailVal)}`);
      const j = await resp.json();
      // Se múltiplos tipos E nenhum tipo escolhido: bloqueia submit e força escolha
      if(Array.isArray(j.tipos) && j.tipos.length > 1 && !tipoHidden.value){
        e.preventDefault();
        // Preenche modal dinamicamente se veio vazio do HTML (lazy loading)
        const lista = modalEl.querySelector('.vstack');
        if(lista && (!lista.children || lista.children.length === 0)){
          lista.innerHTML = '';
          j.tipos.forEach(item => {
            const t = item.slug || item; // compat fallback
            const label = (item.label) || (window.ROTULOS_TIPOS && window.ROTULOS_TIPOS[t]) || (t.charAt(0).toUpperCase()+t.slice(1));
            const b = document.createElement('button');
            b.type = 'button';
            b.className = 'btn btn-outline-primary w-100 escolha-tipo';
            b.setAttribute('data-tipo', t);
            b.textContent = label;
            b.addEventListener('click', function(){
              tipoHidden.value = t;
              if(modalInstance){ modalInstance.hide(); }
              form.submit();
            });
            lista.appendChild(b);
          });
        }
        abrirModalTipos();
        return; // não submeter
      }
      // Caso único tipo: preenche automaticamente o campo hidden
      if(Array.isArray(j.tipos) && j.tipos.length === 1 && !tipoHidden.value){
        const unico = j.tipos[0];
        tipoHidden.value = (unico.slug || unico);
      }
      // Se nenhum tipo: deixa backend validar e retornar erro apropriado
    }catch(_){
      // Silencia erros de rede; backend fará validação definitiva
    }
    // Reforça: se backend sinalizou múltiplos perfis e usuário ainda não escolheu, bloqueia
    if (abrir && !tipoHidden.value){
      e.preventDefault();
      abrirModalTipos();
    }
  });

  // Click nos botões de escolha de tipo dentro do modal: preenche hidden e submete form
  document.querySelectorAll('.escolha-tipo').forEach(btn => {
    btn.addEventListener('click', function(){
      const tipo = this.getAttribute('data-tipo');
      tipoHidden.value = tipo;
      // Fecha modal e submete automaticamente
      if(modalInstance){ modalInstance.hide(); }
      form.submit();
    });
  });

  // Botão cancelar: limpa tipo escolhido e retorna foco ao email (recomeça fluxo)
  document.querySelectorAll('.cancelar-modal-tipo').forEach(btn => {
    btn.addEventListener('click', function(){
      tipoHidden.value='';
      // Delay para aguardar animação de fechamento do modal
      setTimeout(()=> emailInput.focus(), 250);
    });
  });

  // Observa mudanças no email: ao alterar, limpa tipo previamente selecionado (novo email = nova escolha)
  emailInput.addEventListener('input', ()=> { tipoHidden.value=''; });

  // ============================================
  // AUTENTICAÇÃO VIA PASSKEY (WEBAUTHN/FIDO2)
  // ============================================
  // Fluxo alternativo ao código por email: autenticação biométrica/PIN diretamente
  const btnPasskey = document.getElementById('btnPasskeyLogin');
  if(btnPasskey){
    // Verifica se email tem Passkey cadastrada (consulta assíncrona ao backend)
    async function atualizarVisibilidadePasskey(){
      const emailVal = (emailInput.value || '').trim().toLowerCase();
      if(!emailVal){ btnPasskey.style.display = 'none'; return; }
      try{
        const r = await fetch(`/auth/webauthn/tem?email=${encodeURIComponent(emailVal)}`);
        const j = await r.json();
        btnPasskey.style.display = j.tem ? '' : 'none';  // Exibe botão apenas se Passkey existe
      }catch(_){ btnPasskey.style.display = 'none'; }
    }
    
    // Atualiza visibilidade ao perder foco do campo email (debounce natural)
    emailInput.addEventListener('blur', atualizarVisibilidadePasskey);
    emailInput.addEventListener('input', ()=> btnPasskey.style.display='none');
    if((emailInput.value||'').trim()){ atualizarVisibilidadePasskey(); }

    // Funções de conversão base64url ↔ ArrayBuffer (formato FIDO2)
    function b64urlToArrayBuffer(b64url){
      const pad = '='.repeat((4 - b64url.length % 4) % 4);
      const b64 = b64url.replace(/-/g,'+').replace(/_/g,'/') + pad;
      const raw = atob(b64);
      const buffer = new ArrayBuffer(raw.length);
      const view = new Uint8Array(buffer);
      for(let i=0;i<raw.length;i++){view[i]=raw.charCodeAt(i);} return buffer;
    }
    function arrayBufferToB64url(buf){
      const bytes = new Uint8Array(buf); let bin=''; bytes.forEach(b=>bin+=String.fromCharCode(b));
      return btoa(bin).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
    
    // Função principal: realiza login via Passkey (WebAuthn Assertion)
    async function realizarLoginPasskey(tipoEscolhido){
      const emailVal = (emailInput.value || '').trim().toLowerCase();
      if(!emailVal){ alert('Digite o email antes de usar Passkey.'); emailInput.focus(); return; }
      
      // PASSO 1: Obter challenge e opções do servidor
      const params = new URLSearchParams({email: emailVal}); 
      if(tipoEscolhido) params.append('tipo', tipoEscolhido);
      
      let resp = await fetch(`/auth/webauthn/login/opcoes?${params.toString()}`);
      let options = await resp.json();
      if(options.erro){ alert('Não foi possível obter opções de Passkey: ' + options.erro); return; }
      
      // PASSO 2: Converter base64url → ArrayBuffer
      if(options.allowCredentials){ options.allowCredentials = options.allowCredentials.map(c=>({type:c.type,id:b64urlToArrayBuffer(c.id)})); }
      options.challenge = b64urlToArrayBuffer(options.challenge);
      
      try{
        // PASSO 3: Solicitar assertion (mostra diálogo de autenticação)
        const assertion = await navigator.credentials.get({publicKey: options});
        
        // PASSO 4: Serializar assertion para JSON
        const data = { 
          id: assertion.id, 
          rawId: arrayBufferToB64url(assertion.rawId), 
          type: assertion.type, 
          response: { 
            authenticatorData: arrayBufferToB64url(assertion.response.authenticatorData), 
            clientDataJSON: arrayBufferToB64url(assertion.response.clientDataJSON), 
            signature: arrayBufferToB64url(assertion.response.signature), 
            userHandle: assertion.response.userHandle ? arrayBufferToB64url(assertion.response.userHandle) : null 
          }
        };
        
        // Adiciona tipo escolhido ao payload se múltiplos perfis
        if(tipoEscolhido){
          data.tipo = tipoEscolhido;
        }
        
        // PASSO 5: Enviar assertion ao backend para verificação
        const finish = await fetch('/auth/webauthn/login', { 
          method:'POST', 
          headers:{'Content-Type':'application/json'}, 
          body: JSON.stringify(data) 
        });
        const rjson = await finish.json();
        
        if(rjson.status === 'ok'){ 
          window.location.href = '/home'; 
        }
        else if(rjson.erro === 'selecionar_tipo' && Array.isArray(rjson.tipos)){
          // Backend retornou múltiplos perfis: abre modal para escolher
          const lista = modalEl.querySelector('.vstack');
          if(lista){
            lista.innerHTML = '';
            rjson.tipos.forEach(t => {
              const label = (window.ROTULOS_TIPOS && window.ROTULOS_TIPOS[t]) || (t.charAt(0).toUpperCase()+t.slice(1));
              const b = document.createElement('button');
              b.type = 'button';
              b.className = 'btn btn-outline-primary w-100 escolha-tipo-passkey';
              b.setAttribute('data-tipo', t);
              b.textContent = label;
              b.addEventListener('click', async function(){
                // Fecha modal e refaz login com tipo específico
                if(modalInstance){ modalInstance.hide(); }
                await new Promise(r=>setTimeout(r,300));  // Aguarda animação
                realizarLoginPasskey(t);  // Recursivo com tipo
              });
              lista.appendChild(b);
            });
            abrirModalTipos();
          }
        }
        else { 
          alert('Falha no login Passkey: ' + (rjson.erro || 'desconhecido')); 
        }
      }catch(e){ 
        console.error(e); 
        alert('Falha ao realizar autenticação Passkey.'); 
      }
    }
    
    // Event listener: clique no botão inicia fluxo Passkey
    btnPasskey.addEventListener('click', () => realizarLoginPasskey(null));
  }
})();
</script>
{% endblock %}
